package com.nms.model.ptn;

import java.sql.Connection;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;

import com.nms.db.bean.ptn.LabelInfo;
import com.nms.db.bean.ptn.path.pw.PwInfo;
import com.nms.db.bean.ptn.path.tunnel.Lsp;
import com.nms.db.dao.ptn.LabelInfoDao;
import com.nms.db.dao.ptn.path.pw.PwInfoDao;
import com.nms.model.equipment.shlef.SiteService;
import com.nms.model.ptn.path.tunnel.LspService;
import com.nms.model.util.LabelManage;
import com.nms.model.util.ObjectService;
import com.nms.model.util.Services;
import com.nms.ui.manager.ConstantUtil;
import com.nms.ui.manager.ExceptionManage;

public class LabelInfoService extends ObjectService {

	public void setConnection(Connection connection) {
		super.connection = connection;
	}

	public void setPtnuser(String ptnuser) {
		super.ptnuser = ptnuser;
	}

	private LabelInfoDao labelInfoDao = new LabelInfoDao();

	/**
	 * 新增或修改LabelInfo对象，通过LabelInfo.getId()来判断是修改还是新增
	 * @param labelinfo 实体
	 * @return 执行成功的记录数
	 * @throws Exception
	 */
//	public void saveBatch(List<LabelInfo> labelinfos,String type) throws Exception {
//		if (labelinfos == null) {
//			throw new Exception("labelinfo is null");
//		}
//		int manufacturer = 0;
//		SiteService siteService = null;
//		try {
//			//目前设备的芯片不支持同一端口的lsp的入标签和该端口上的pw的入标签一样,所以要用下面的代码
//			if(type.equals("TUNNEL") || type.equals("PW")){
//				type = "WH";
//			}
//			//如果以后芯片支持同一端口的lsp的入标签和该端口上的pw的入标签一样,就用下面的代码,把上面的代码关掉
//			siteService = (SiteService) ConstantUtil.serviceFactory.newService(Services.SITE, this.connection);
//			List<LabelInfo> labelInfoList = new ArrayList<LabelInfo>();
//			for (LabelInfo labelInfo : labelinfos) {
//				manufacturer = siteService.getManufacturer(labelInfo.getSiteid());
//				if(manufacturer == 1){
//					labelInfo.setType("CX");
//				}
//				if (this.select(labelInfo).size() == 0) {
//					labelInfoList.add(labelInfo);
//				}
//			}
//			labelInfoDao.insertBatch(labelInfoList,type, connection);
//		} catch (Exception e) {
//			ExceptionManage.dispose(e,this.getClass());
//		} finally {
////			UiUtil.closeService(siteService);
//		}
//	}

	/**
	 * 批量修改
	 * @throws Exception
	 */
	public void updateBatch(int labelValue, int siteid, int status, String type) throws Exception {
		int manufacturer = 0;
		SiteService siteService = null;
		try {
			//目前设备的芯片不支持同一端口的lsp的入标签和该端口上的pw的入标签一样,所以要用下面的代码
			if(type.equals("TUNNEL") || type.equals("PW")){
				type = "WH";
			}
			//如果以后芯片支持同一端口的lsp的入标签和该端口上的pw的入标签一样,就用下面的代码,把上面的代码关掉
			siteService = (SiteService) ConstantUtil.serviceFactory.newService(Services.SITE, this.connection);
			manufacturer = siteService.getManufacturer(siteid);
			if(manufacturer == 1){
				type = "CX";
			}
			labelInfoDao.updateStatusBatch(labelValue, siteid, status, type ,connection);
		} catch (Exception e) {
			ExceptionManage.dispose(e,this.getClass());
		} finally {
//			UiUtil.closeService(siteService);
		}
	}

	public void saveOrUpdate(int labelValue, int siteid, int status, String type, Connection connection) throws Exception {
		int manufacturer = 0;
		SiteService siteService = null;
		try {
			//目前设备的芯片不支持同一端口的lsp的入标签和该端口上的pw的入标签一样,所以要用下面的代码
			if(type.equals("TUNNEL") || type.equals("PW")){
				type = "WH";
			}
			//如果以后芯片支持同一端口的lsp的入标签和该端口上的pw的入标签一样,就用下面的代码,把上面的代码关掉
			siteService = (SiteService) ConstantUtil.serviceFactory.newService(Services.SITE, this.connection);
			manufacturer = siteService.getManufacturer(siteid);
			if(manufacturer == 1){
				type = "CX";
			}
			List<LabelInfo> labelInfos = this.labelInfoDao.quertyByLabelValue(labelValue, siteid, 0, type, connection);
			if (labelInfos.size() > 0) {
				this.updateBatch(labelValue, siteid, status, type);
			} else {
				LabelInfo labelInfo = new LabelInfo();
				labelInfo.setLabelStatus(status);
				labelInfo.setSiteid(siteid);
				labelInfo.setLabelValue(labelValue);
				labelInfo.setType(type);
				this.labelInfoDao.insert(labelInfo,connection);
			}
		} catch (Exception e) {
			ExceptionManage.dispose(e,this.getClass());
		} finally {
//			UiUtil.closeService(siteService);
		}
	}

	/**
	 * 根据主键删除LabelInfo对象
	 * @param id
	 * @return 删除成功的记录数
	 * @throws Exception
	 */
	public int delete(int id) throws Exception {
		int result = 0;
		try {
			result = labelInfoDao.delete(id, connection);
		} catch (Exception e) {
			ExceptionManage.dispose(e,this.getClass());
		}
		return result;
	}

	/**
	 * 查询全部
	 * @return List<LabelInfo> 集合
	 * @throws Exception
	 */
	public List<LabelInfo> select() throws Exception {
		List<LabelInfo> labelinfoList = new ArrayList<LabelInfo>();
		try {
			LabelInfo labelinfo = new LabelInfo();
			labelinfoList = labelInfoDao.queryByCondition(labelinfo, connection);
		} catch (Exception e) {
			ExceptionManage.dispose(e,this.getClass());
		}
		return labelinfoList;
	}

	/**
	 * 根据条件查询
	 * @param labelinfo 查询条件
	 * @return List<LabelInfo> 集合
	 * @throws Exception
	 */
	public List<LabelInfo> select(LabelInfo labelinfo) throws Exception {
		List<LabelInfo> labelinfoList = new ArrayList<LabelInfo>();
		SiteService siteService = null;
		try {
			String type = labelinfo.getType();
			//目前设备的芯片不支持同一端口的lsp的入标签和该端口上的pw的入标签一样,所以要用下面的代码
			if(type.equals("TUNNEL") || type.equals("PW")){
				type = "WH";
			}
			//如果以后芯片支持同一端口的lsp的入标签和该端口上的pw的入标签一样,就用下面的代码,把上面的代码关掉
			if(labelinfo.getSiteid() > 0 && ("TUNNEL".equals(type) || "PW".equals(type))){
				int manufacturer = 0;
				siteService = (SiteService) ConstantUtil.serviceFactory.newService(Services.SITE, this.connection);
				manufacturer = siteService.getManufacturer(labelinfo.getSiteid());
				if(manufacturer == 1)
					labelinfo.setType("CX");
			}
			labelinfoList = labelInfoDao.queryByCondition(labelinfo, connection);
		} catch (Exception e) {
			ExceptionManage.dispose(e,this.getClass());
		} finally {
//			UiUtil.closeService(siteService);
		}
		return labelinfoList;
	}

	/**
	 * 查询一组标签是否可用
	 * 
	 * @param labelValues
	 * @param status
	 * @return
	 * @throws Exception
	 */
	public String select(List<Integer> labelValues, int siteId,String type) throws Exception {

		String result = "";
		List<LabelInfo> labelInfos = null;
		SiteService siteService = null;
		try {
			//目前设备的芯片不支持同一端口的lsp的入标签和该端口上的pw的入标签一样,所以要用下面的代码
			if(type.equals("TUNNEL") || type.equals("PW")){
				type = "WH";
			}
			//如果以后芯片支持同一端口的lsp的入标签和该端口上的pw的入标签一样,就用下面的代码,把上面的代码关掉
			siteService = (SiteService) ConstantUtil.serviceFactory.newService(Services.SITE, this.connection);
			int manufacturer = siteService.getManufacturer(siteId);
			//等于1是晨晓设备,入标签网元唯一
			if(manufacturer == 0){
				labelInfos = this.labelInfoDao.queryByLabelvalues(labelValues, siteId, type,connection);
			}else{
				labelInfos = this.labelInfoDao.queryByLabelvaluesForCX(labelValues, siteId, connection);
			}
			
			if (labelInfos != null) {
				int i = 1;
				for (LabelInfo labelInfo : labelInfos) {
					if(i <= 2){
						result += labelInfo.getLabelValue() + ",";
					}
					i++;
				}
				// if (result.length() > 0) {
				// result = result.substring(0, result.length() - 1);
				// }
			}
		} catch (Exception e) {
			ExceptionManage.dispose(e,this.getClass());
		} finally {
//			UiUtil.closeService(siteService);
		}
		return result;
	}

	/**
	 * 通过出标签和端口ID 验证此出标签是否可用。 通过portid查询出此port下所有tunnel 验证每个tunnel的出标签是否与outLabel相同，如果相同，结束循环，返回false。 通过所有tunnel，查询pw集合，如果是pw的A Z两端就验证pw的出标签是否与outLabel相同，如果相同，结束循环，返回false
	 * 
	 * @param outLabel
	 *            要验证出标签
	 * @param portId
	 *            端口表主键
	 * @param siteId
	 *            网元主键
	 * @param type
	 * 			  类型,即tunnel和pw,武汉设备可以区分tunnel和pw的标签,所以tunnel和pw的出标签可以一致,不用做区分
	 * @return true 验证通过 false 验证不通过。
	 * @throws Exception
	 */
	public boolean checkingOutLabel(int outLabel, int portId, int siteId, String type) throws Exception {
		boolean result = true;
		LspService lspService = null;
		try {
			List<Integer> tunnelIdList = new ArrayList<Integer>();
			// 查询此端口下的所有LSP 
		    lspService = (LspService) ConstantUtil.serviceFactory.newService(Services.LSPINFO, this.connection);
			List<Lsp> lspList = lspService.selectByPort(portId);

			if(type.equals("TUNNEL")){
				// 遍历lsp。比较outLabel签是否与lsp的出标签相同，如果有一个相同，结束方法，返回false
				if (null != lspList && lspList.size() > 0) {
					for (Lsp lsp : lspList) {

						// 如果此端口是A端， 前向标签为出标签
						if (portId == lsp.getAPortId()) {
							if (outLabel == lsp.getFrontLabelValue()) {
								result = false;
								break;
							}
						} else {
							// 如果此端口是Z端，后向标签为出标签
							if (outLabel == lsp.getBackLabelValue()) {
								result = false;
								break;
							}
						}
					}
				}
			}else if(type.equals("PW")){
				if (null != lspList && lspList.size() > 0) {
					for (Lsp lsp : lspList) {
						// 如果集合中不存在此tunnel主键，就添加到集合中
						if (!tunnelIdList.contains(lsp.getTunnelId())) {
							tunnelIdList.add(lsp.getTunnelId());
						}
					}
				}
				//根据tunnelid集合查询pw
				PwInfoDao pwInfoDao = new PwInfoDao();
				List<PwInfo> pwInfoList = pwInfoDao.queryByPwTunnelIdCondition(tunnelIdList, connection);
				//遍历pw，比较pw的出标签是否有和outLabel相同的
				if (null != pwInfoList && pwInfoList.size() > 0) {
					
					for(PwInfo pwInfo : pwInfoList){
						// 如果此网元是A端， 前向标签为出标签
						if(pwInfo.getASiteId() == siteId){
							if (outLabel == pwInfo.getInlabelValue()) {
								result = false;
								break;
							}
						}else if(pwInfo.getZSiteId() == siteId){
							// 如果此网元是Z端，后向标签为出标签
							if (outLabel == pwInfo.getOutlabelValue()) {
								result = false;
								break;
							}
						}
					}
				}
			}
		} catch (Exception e) {
			throw e;
		} finally {
//			UiUtil.closeService(lspService);
		}
		return result;
	}

	/**
	 * 从labelInfo里查找可用的label
	 * 找出A,Z端都可用的标签
	 * @param aSiteId
	 * @param zSiteId
	 * @param labelInfoDao
	 * @param conn
	 * @return
	 * @throws Exception
	 */
	public String matchingUsableLabel(int aSiteId, int zSiteId, Map<String, String> siteId_PortIdMap, List<Integer> labelValues, String type) throws Exception {
		int front_label = 0;
		int back_label = 0;
		String label = null;
		List<Integer> labelList = null;
		int aPortId = Integer.parseInt(siteId_PortIdMap.get(aSiteId+"-"+zSiteId).split("-")[0]);
		int zPortId = Integer.parseInt(siteId_PortIdMap.get(aSiteId+"-"+zSiteId).split("-")[1]);
		SiteService siteService = (SiteService) ConstantUtil.serviceFactory.newService(Services.SITE, this.connection);
		//等于1是晨晓设备,入标签网元唯一
		int manufacturerA = siteService.getManufacturer(aSiteId);
		int manufacturerZ = siteService.getManufacturer(zSiteId);
		//目前设备的芯片不支持同一端口的lsp的入标签和该端口上的pw的入标签一样,所以要用下面的代码
		if(type.equals("TUNNEL") || type.equals("PW")){
			type = "WH";
		}
		//如果以后芯片支持同一端口的lsp的入标签和该端口上的pw的入标签一样,就用下面的代码,把上面的代码关掉
//		UiUtil.closeService(siteService);
		//先分配前向标签,并验证出标签是否可用
		labelList = labelInfoDao.quertyLabelListBySite(aSiteId, zSiteId, labelValues, type, connection, 
														manufacturerA, manufacturerZ);
		Collections.shuffle(labelList);
		//this.removeRepeatedLabel(labelList);
		if(labelList.size() > 0){
			for (Integer integer : labelList) {
				if(checkingOutLabel(integer, aPortId, aSiteId, type)){
					front_label = integer;
					break;
				}
			}
		}
		labelList.clear();
		if (front_label == 0) {
			labelList = this.matchingNoLabel(aSiteId, zSiteId, labelValues, type);
			for (Integer integer : labelList) {
				if(checkingOutLabel(integer, aPortId, aSiteId, type)){
					front_label = integer;
					break;
				}
			}
		}
		//再分配后向标签
		labelValues.add(front_label);
		labelList.clear();
		labelList = labelInfoDao.quertyLabelListBySite(aSiteId, zSiteId, labelValues,type, connection,
														manufacturerA, manufacturerZ);
		Collections.shuffle(labelList);
		//this.removeRepeatedLabel(labelList);
		if(labelList.size() > 0){
			for (Integer integer : labelList) {
				if(checkingOutLabel(integer, zPortId, zSiteId, type)){
					back_label = integer;
					break;
				}
			}
		}
		labelList.clear();
		if (back_label == 0) {
			labelList = this.matchingNoLabel(aSiteId, zSiteId, labelValues,type);
			for (Integer integer : labelList) {
				if(checkingOutLabel(integer, zPortId, zSiteId, type)){
					back_label = integer;
					break;
				}
			}
		}
		label = front_label+","+back_label;
		return label;
	}

	/**
	 * 如果没有可用的标签，则根据规则分配标签
	 * @param asiteId
	 * @param zsiteId
	 * @param labelInfoDao
	 * @param connection
	 * @return
	 * @throws Exception
	 */
	private List<Integer> matchingNoLabel(int asiteId, int zsiteId, List<Integer> labelValues, String type) throws Exception {
		List<Integer> labelList = null;
		SiteService siteService = null;
		try {
			//目前设备的芯片不支持同一端口的lsp的入标签和该端口上的pw的入标签一样,所以要用下面的代码
			if(type.equals("TUNNEL") || type.equals("PW")){
				type = "WH";
			}
			//如果以后芯片支持同一端口的lsp的入标签和该端口上的pw的入标签一样,就用下面的代码,把上面的代码关掉
			siteService = (SiteService) ConstantUtil.serviceFactory.newService(Services.SITE, this.connection);
			//等于1是晨晓设备,入标签网元唯一
			int manufacturerA = siteService.getManufacturer(asiteId);
			int manufacturerZ = siteService.getManufacturer(zsiteId);
			LabelManage labelManage = new LabelManage();
			while (true) {	
				labelManage.addLabel(asiteId, zsiteId, type, connection);
				labelList = labelInfoDao.quertyLabelListBySite(asiteId, zsiteId, labelValues,type, connection,manufacturerA, manufacturerZ);
				if (labelList.size() > 0) {
					break;
				}
			}
		} catch (Exception e) {
			ExceptionManage.dispose(e,this.getClass());
		} finally {
//			UiUtil.closeService(siteService);
		}
		return labelList;
	}

	/**
	 * @param aSiteId
	 * @return
	 * @throws Exception
	 */
	public List<Integer> quertyAllLabel(int aSiteId, String type) throws Exception {
		SiteService siteService = (SiteService) ConstantUtil.serviceFactory.newService(Services.SITE, this.connection);
		//等于1是晨晓设备,入标签网元唯一
		int manufacturer = siteService.getManufacturer(aSiteId);
//		UiUtil.closeService(siteService);
		if(manufacturer == 1){
			type = "CX";
		}
		//目前设备的芯片不支持同一端口的lsp的入标签和该端口上的pw的入标签一样,所以要用下面的代码
		if(type.equals("TUNNEL") || type.equals("PW")){
			type = "WH";
		}
		//如果以后芯片支持同一端口的lsp的入标签和该端口上的pw的入标签一样,就用下面的代码,把上面的代码关掉
		return this.labelInfoDao.quertyAllLabel(aSiteId, type, connection);
	}

	/**
	 * 根据标签值查询标签是否可用
	 * @param labelValue
	 * @param siteId
	 * @param connection
	 * @return
	 * @throws Exception
	 */
	public boolean isUsedLabel(int labelValue, int asiteId, String type) throws Exception {
		SiteService siteService = (SiteService) ConstantUtil.serviceFactory.newService(Services.SITE, this.connection);
		int manufacturer = siteService.getManufacturer(asiteId);
//		UiUtil.closeService(siteService);
		//等于1是晨晓设备,入标签网元唯一
		//目前设备的芯片不支持同一端口的lsp的入标签和该端口上的pw的入标签一样,所以要用下面的代码
		if(type.equals("TUNNEL") || type.equals("PW")){
			type = "WH";
		}
		//如果以后芯片支持同一端口的lsp的入标签和该端口上的pw的入标签一样,就用下面的代码,把上面的代码关掉
		if(manufacturer == 1){
			return labelInfoDao.isUsedLabelForCX(labelValue, asiteId, connection);
		}else{
			return labelInfoDao.isUsedLabel(labelValue, asiteId, type, connection);
		}
	}

	/**
	 * 分配16到100的标签
	 */
	public void matchingLabel(int siteId, String type) throws Exception {
		int begin = 16;
		int end = 100;
		try {
			//目前设备的芯片不支持同一端口的lsp的入标签和该端口上的pw的入标签一样,所以要用下面的代码
			if(type.equals("TUNNEL") || type.equals("PW")){
				type = "WH";
			}
			//如果以后芯片支持同一端口的lsp的入标签和该端口上的pw的入标签一样,就用下面的代码,把上面的代码关掉
			List<LabelInfo> labelInfos = new ArrayList<LabelInfo>();
			for(int i = begin ; i <= end ; i++){
				LabelInfo labelInfo = new LabelInfo();
				labelInfo.setLabelStatus(1);
				labelInfo.setSiteid(siteId);
				labelInfo.setLabelValue(i);
				labelInfo.setType(type);
				if(i == end){
					labelInfo.setLsrId(1);
				}
				labelInfos.add(labelInfo);
			}
			labelInfoDao.insertBatch(labelInfos,type, connection);
		} catch (Exception e) {
			ExceptionManage.dispose(e,LabelManage.class);
		}
	}

	
	public void insertNewLabel(int labelValue, int siteId, String type) {
		int manufacturer = 0;
		SiteService siteService = null;
		try {
			//目前设备的芯片不支持同一端口的lsp的入标签和该端口上的pw的入标签一样,所以要用下面的代码
			if(type.equals("TUNNEL") || type.equals("PW")){
				type = "WH";
			}
			//如果以后芯片支持同一端口的lsp的入标签和该端口上的pw的入标签一样,就用下面的代码,把上面的代码关掉
			siteService = (SiteService) ConstantUtil.serviceFactory.newService(Services.SITE, this.connection);
			manufacturer = siteService.getManufacturer(siteId);
			if(manufacturer == 1){
				type = "CX";
			}
			labelInfoDao.insertNewLabel(labelValue, siteId, type ,connection);
		}catch (Exception e) {
			ExceptionManage.dispose(e, this.getClass());
		} finally {
//			UiUtil.closeService(siteService);
		}
	}

	public List<LabelInfo> selectUsedLabel(LabelInfo labelinfo) {
		List<LabelInfo> labelinfoList = new ArrayList<LabelInfo>();
		SiteService siteService = null;
		try {
			//目前设备的芯片不支持同一端口的lsp的入标签和该端口上的pw的入标签一样,所以要用下面的代码
			if(labelinfo.getType().equals("TUNNEL") || labelinfo.getType().equals("PW")){
				labelinfo.setType("WH");
			}
			//如果以后芯片支持同一端口的lsp的入标签和该端口上的pw的入标签一样,就用下面的代码,把上面的代码关掉
			String type = labelinfo.getType();
			if(labelinfo.getSiteid() > 0 && ("TUNNEL".equals(type) || "PW".equals(type))){
				int manufacturer = 0;
				siteService = (SiteService) ConstantUtil.serviceFactory.newService(Services.SITE, this.connection);
				manufacturer = siteService.getManufacturer(labelinfo.getSiteid());
				if(manufacturer == 1)
					labelinfo.setType("CX");
			}
			labelinfoList = labelInfoDao.selectUsedLabel(labelinfo, connection);
		} catch (Exception e) {
			ExceptionManage.dispose(e,this.getClass());
		} finally {
//			UiUtil.closeService(siteService);
		}
		return labelinfoList;
	}
	
	/**
	 * 将所有已使用的标签状态改为未使用，0改为1
	 */
	public void initAllLabel(){
		try {
			this.labelInfoDao.initAllLabel(this.connection);
		} catch (Exception e) {
			ExceptionManage.dispose(e,this.getClass());
		}
	}
}
