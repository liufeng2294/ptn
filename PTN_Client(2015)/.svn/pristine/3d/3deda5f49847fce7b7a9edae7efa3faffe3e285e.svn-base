package com.nms.model.ptn.port;

import java.sql.Connection;
import java.util.ArrayList;
import java.util.List;

import com.nms.db.bean.ptn.Businessid;
import com.nms.db.bean.ptn.oam.OamInfo;
import com.nms.db.bean.ptn.port.AcPortInfo;
import com.nms.db.bean.ptn.port.Acbuffer;
import com.nms.db.bean.ptn.port.PortLagInfo;
import com.nms.db.bean.ptn.qos.QosInfo;
import com.nms.db.bean.ptn.qos.QosRelevance;
import com.nms.db.dao.ptn.BusinessidDao;
import com.nms.db.dao.ptn.port.AcDao;
import com.nms.db.dao.ptn.qos.QosInfoDao;
import com.nms.db.dao.ptn.qos.QosRelevanceDao;
import com.nms.db.enums.EActionType;
import com.nms.db.enums.EManufacturer;
import com.nms.db.enums.EServiceType;
import com.nms.db.enums.OamTypeEnum;
import com.nms.model.equipment.shlef.SiteService;
import com.nms.model.ptn.oam.OamInfoService;
import com.nms.model.ptn.qos.QosInfoService;
import com.nms.model.ptn.qos.QosRelevanceService;
import com.nms.model.util.ObjectService;
import com.nms.model.util.Services;
import com.nms.ui.manager.BusinessIdException;
import com.nms.ui.manager.ConstantUtil;
import com.nms.ui.manager.ExceptionManage;

public class AcInfoService extends ObjectService {

	public void setConnection(Connection connection) {
		super.connection = connection;
	}

	public void setPtnuser(String ptnuser) {
		super.ptnuser = ptnuser;
	}

	private AcDao acDao = new AcDao();
	private BusinessidDao businessidDao = new BusinessidDao();
	private final static int ISUSEDSTATUS = 1;

	public int saveOrUpdate(List<Acbuffer> bufferInfos, AcPortInfo acPortInfo) throws Exception, BusinessIdException {

//		List<QosInfo> qosInfoList = null;
		if (acPortInfo == null) {
			throw new Exception("acPortInfos is null");
		}
		OamInfoService oamInfoService = null;
		AcBufferService bufservice = null;
//		QosInfoService qosInfoService = null;
		int result = 0;
		int acId = 0;
		QosRelevanceService qosRelevanceService = null;
		List<QosRelevance> qosRelevanceList = null;
		SiteService siteService = null;
		PortLagService portLagService = null;
		try {

			connection.setAutoCommit(false);
			bufservice = (AcBufferService) ConstantUtil.serviceFactory.newService(Services.UniBuffer, this.connection);
//			qosInfoService = (QosInfoService) ConstantUtil.serviceFactory.newService(Services.QosInfo, this.connection);
			oamInfoService = (OamInfoService) ConstantUtil.serviceFactory.newService(Services.OamInfo, this.connection);
			siteService = (SiteService) ConstantUtil.serviceFactory.newService(Services.SITE, this.connection);
			// 下发Ac
			if (acPortInfo.getId() > 0) {
				acDao.update(acPortInfo, connection);
				// 设置ac与流的关联关系，下发流
				for (Acbuffer buffer : bufferInfos) {
					// if (buffer.getAcId() == 0) {
					buffer.setAcId(acPortInfo.getId());
					buffer.setPortId(acPortInfo.getPortId());
					// }
				}
				result = acPortInfo.getId();

				acPortInfo.getSimpleQos().setQosname(null);
				// 离线网元数据下载
				if (!acPortInfo.isDataDownLoad()) {
					super.dateDownLoad(acPortInfo.getSiteId(), result, EServiceType.ACPORT.getValue(), EActionType.UPDATE.getValue());
				}
			} else {

				if (siteService.getManufacturer(acPortInfo.getSiteId()) != EManufacturer.WUHAN.getValue()) {
					Businessid acSerBusinessId = null;
					if (acPortInfo.getAcBusinessId() == 0) {
						acSerBusinessId = businessidDao.query(acPortInfo.getSiteId(), "ac", connection);
					} else {
						acSerBusinessId = businessidDao.query(acPortInfo.getAcBusinessId(), acPortInfo.getSiteId(), "ac", connection);
					}

					if (acSerBusinessId == null) {
						throw new BusinessIdException("acSerBusinessId is null");
					}
					acPortInfo.setAcBusinessId(acSerBusinessId.getIdValue());
					acId = acDao.insert(acPortInfo, connection);
					businessidDao.update(acSerBusinessId.getId(), ISUSEDSTATUS, connection);
					// 离线网元数据下载
					super.dateDownLoad(acPortInfo.getSiteId(), acId, EServiceType.ACPORT.getValue(), EActionType.INSERT.getValue());
				} else {
					acId = acDao.insert(acPortInfo, connection);
				}
				// 设置ac与流的关联关系，下发流
				for (Acbuffer buffer : bufferInfos) {
					if (buffer.getAcId() == 0) {
						buffer.setAcId(acId);
						buffer.setPortId(acPortInfo.getPortId());
					}
				}
				acPortInfo.setId(acId);
				result = acId;
				acPortInfo.setId(acId);
			}
			if(bufferInfos.size()>0){
				acPortInfo.getSimpleQos().setBufferList(bufferInfos);
			}
				qosRelevanceService=(QosRelevanceService) ConstantUtil.serviceFactory.newService(Services.QOSRELEVANCE, this.connection);
				qosRelevanceList = qosRelevanceService.getList(acPortInfo);
				qosRelevanceService.save(qosRelevanceList);
				if (siteService.getManufacturer(acPortInfo.getSiteId()) != EManufacturer.CHENXIAO.getValue()) {
					// 保存或者更新细分流
					if (!bufferInfos.isEmpty()) {
						bufservice.saveOrUpdate(bufferInfos);
					}
				}else{
					acPortInfo.setSimpleQos(qosRelevanceList.get(0).getQosInfoList().get(0));
				}
//			if (acPortInfo.getSimpleQos() != null) {
//				acPortInfo.getSimpleQos().setObjId(result);
//				acPortInfo.getSimpleQos().setQosType(null);
//				if (null == acPortInfo.getSimpleQos().getQosname() || "".equals(acPortInfo.getSimpleQos().getQosname())) {
//					if ("0".equals(UiUtil.getCodeById(acPortInfo.getBufType()).getCodeValue())) {
//						acPortInfo.getSimpleQos().setQosname("l2" + result);
//					} else if ("1".equals(UiUtil.getCodeById(acPortInfo.getBufType()).getCodeValue())) {
//						acPortInfo.getSimpleQos().setQosname("l3" + result);
//					} else if ("2".equals(UiUtil.getCodeById(acPortInfo.getBufType()).getCodeValue())) {
//						acPortInfo.getSimpleQos().setQosname("vlanpri" + result);
//					}
//				}
////				acPortInfo.getSimpleQos().setQosname();
//				qosInfoList = new ArrayList<QosInfo>();
//				qosInfoList.add(acPortInfo.getSimpleQos());
//				qosInfoService.saveOrUpdate(qosInfoList);
//			}
			// lag与ac的关联
			if (acPortInfo.getLagId() > 0) {// 如果ac为lag，把相应的lag变为被使用
				portLagService = (PortLagService) ConstantUtil.serviceFactory.newService(Services.PORTLAG, this.connection);
				PortLagInfo portLagInfo = new PortLagInfo();
				portLagInfo.setId(acPortInfo.getLagId());
				portLagInfo.setType(1);
				portLagInfo = portLagService.selectLAGByCondition(portLagInfo).get(0);
				portLagInfo.setIsUsed(1);
				portLagService.updateStatus(portLagInfo);
			}
			if (acPortInfo.getOamList() != null && acPortInfo.getOamList().size() > 0) {
				List<OamInfo> oamList = acPortInfo.getOamList();
				for (OamInfo oamInfo : oamList) {
					if (oamInfo.getOamType() == OamTypeEnum.AMEP || oamInfo.getOamType() == OamTypeEnum.ZMEP) {
						oamInfo.getOamMep().setServiceId(acId);
						oamInfo.getOamMep().setObjId(acPortInfo.getAcBusinessId());
					} else if (oamInfo.getOamType() == OamTypeEnum.MEP) {

					} else if (oamInfo.getOamType() == OamTypeEnum.MIP) {

					}
					oamInfoService.saveOrUpdate(oamInfo);
				}
			}
			if(!connection.getAutoCommit()){
				connection.commit();
			}
		} catch (Exception e) {
			connection.rollback();
			ExceptionManage.dispose(e, this.getClass());
		} finally {
			connection.setAutoCommit(true);
		}
		return result;
	}

	/**
	 * 根据网元ID获取网元厂商
	 * 
	 * @param siteId
	 *            网元主键
	 * @return 厂商
	 * @throws Exception
	 */
	/*
	 * private String getManufacturer(int siteId) throws Exception { String manufacturer = null; SiteService siteService = null; SiteInst siteInst = null; try { siteService = (SiteService) ConstantUtil.serviceFactory .newService(Services.SITE); siteInst = siteService.select(siteId); if (siteInst == null) { throw new Exception("根据ID查询网元出错"); } manufacturer = UiUtil.getCodeById( Integer.parseInt(siteInst.getCellEditon())).getCodeName(); return manufacturer; } catch (Exception e) { throw e; } finally { siteService = null; siteInst = null; } }
	 */
	public int update(AcPortInfo acPortInfo) throws Exception {
		int result = 0;
		OamInfoService oamInfoService = null;
		QosRelevanceService qosRelevanceService = null;
		List<QosRelevance> qosRelevanceList = null;
		AcBufferService acBufferService = null;
		try {
			connection.setAutoCommit(false);
			oamInfoService = (OamInfoService) ConstantUtil.serviceFactory.newService(Services.OamInfo, this.connection);
			result = acDao.update(acPortInfo, connection);
			// 离线网元数据下载
			if (!acPortInfo.isDataDownLoad()) {
				super.dateDownLoad(acPortInfo.getSiteId(), acPortInfo.getId(), EServiceType.ACPORT.getValue(), EActionType.UPDATE.getValue());
			}
			// 保存或者更新简单流
			qosRelevanceService = (QosRelevanceService) ConstantUtil.serviceFactory.newService(Services.QOSRELEVANCE, this.connection);
			qosRelevanceList = qosRelevanceService.getList(acPortInfo);
			qosRelevanceService.save(qosRelevanceList);

			List<OamInfo> oamList = acPortInfo.getOamList();
			if (oamList != null && oamList.size() > 0) {
				for (OamInfo oamInfo : oamList) {
					if (oamInfo.getOamType() == OamTypeEnum.AMEP || oamInfo.getOamType() == OamTypeEnum.ZMEP || oamInfo.getOamType() == OamTypeEnum.MEP) {
						oamInfo.getOamMep().setServiceId(acPortInfo.getId());
						oamInfo.getOamMep().setObjId(acPortInfo.getSiteId());
						oamInfo.setOamType(OamTypeEnum.MEP);
					} else if (oamInfo.getOamType() == OamTypeEnum.MIP) {

					}
					oamInfoService.saveOrUpdate(oamInfo);
				}
			}
			acBufferService = (AcBufferService) ConstantUtil.serviceFactory.newService(Services.UniBuffer,this.connection);
			for (Acbuffer buffer : acPortInfo.getBufferList()) {
				if (buffer.getAcId() == 0) {
					buffer.setAcId(acPortInfo.getId());
					buffer.setPortId(acPortInfo.getPortId());
				}
			}
			acBufferService.deletebyAcId(acPortInfo.getId());
			acBufferService.saveOrUpdate(acPortInfo.getBufferList());
			connection.commit();
		} catch (Exception e) {
			connection.rollback();
			throw e;
		} finally {
//			UiUtil.closeService(oamInfoService);
//			UiUtil.closeService(qosRelevanceService);
			connection.setAutoCommit(true);
		}
		return result;

	}

	/**
	 * 删除
	 * 
	 * @param acId
	 * @return
	 * @throws Exception
	 */
	public void delete(int acId) throws Exception {
		List<Integer> acIdList = null;
		try {
			acIdList = new ArrayList<Integer>();
			acIdList.add(acId);
			this.delete(acIdList);
		} catch (Exception e) {
			throw e;
		} finally {
			acIdList = null;
		}
	}

	/**
	 * 批量删除ac
	 * 
	 * @param acIdList
	 * @throws Exception
	 */
	public void delete(List<Integer> acIdList) throws Exception {
		if (acIdList.isEmpty()) {
			throw new Exception("acId List为空");
		}
		List<AcPortInfo> acportInfoList = null;
		Businessid businessid = null;
		QosRelevanceDao qosRelevanceDao = null;
		QosRelevance qosRelevance = null;
		List<PortLagInfo> portLagInfoList;
		PortLagService portLagService = (PortLagService) ConstantUtil.serviceFactory.newService(Services.PORTLAG, this.connection);
		AcBufferService bufservice = null;
		QosInfoDao qosInfoDao = null;
		try {
			connection.setAutoCommit(false);
			acportInfoList = acDao.queryByAcIdCondition(acIdList, connection);
			// if (UiUtil.getManufacturer(ConstantUtil.siteId) != EManufacturer.WUHAN.getValue()) {
			if (!acportInfoList.isEmpty()) {
				for (AcPortInfo acInfo : acportInfoList) {
					businessid = new Businessid();
					businessid.setIdStatus(0);
					businessid.setType("ac");
					businessid.setSiteId(acInfo.getSiteId());
					businessid.setIdValue(acInfo.getAcBusinessId());
					businessidDao.updateBusinessid(businessid, connection);
					// 离线网元数据下载
					if (0 != acInfo.getLagId()) {
						PortLagInfo portLagInfo = new PortLagInfo();
						portLagInfo.setLagID(acInfo.getLagId());
						portLagInfoList = portLagService.selectByCondition(portLagInfo);
						if (null != portLagInfoList && portLagInfoList.size() > 0) {
							portLagInfo = portLagInfoList.get(0);
							super.dateDownLoad(acInfo.getSiteId(), acInfo.getId(), EServiceType.ACPORT.getValue(), EActionType.DELETE.getValue(), acInfo.getAcBusinessId() + "", portLagInfo.getLagID() + "", acInfo.getPortId(), acInfo.getAcBusinessId(), null);
						}
					} else {
						super.dateDownLoad(acInfo.getSiteId(), acInfo.getId(), EServiceType.ACPORT.getValue(), EActionType.DELETE.getValue(), acInfo.getAcBusinessId() + "", "", acInfo.getPortId(), acInfo.getAcBusinessId(), null);
					}
				}
			}
			// }
			// 删除对应ac的细分流
			bufservice = (AcBufferService) ConstantUtil.serviceFactory.newService(Services.UniBuffer, this.connection);
			for (Integer id : acIdList) {
				bufservice.deletebyAcId(id); // 删除细分流
				qosInfoDao = new QosInfoDao();
				qosRelevanceDao = new QosRelevanceDao();
				//删除之前先判断该条QoS是否被其他ac使用，如果被其他ac使用，则不删除，否则删除
				//先删除qosInfo,再删除qosRelevance
				List<QosRelevance> qosRelavanceList = this.getQosRelevanceList(id);
				this.checkIsOccupy(id, qosRelavanceList);
				if(qosRelavanceList != null && !qosRelavanceList.isEmpty()){
					for (QosRelevance relevance : qosRelavanceList) {
						if(!relevance.isRepeat()){
							qosInfoDao.deleteByGroupId(relevance.getQosGroupId(), connection);
						}
					}
				}
				qosRelevance = new QosRelevance();
				qosRelevance.setObjType(EServiceType.ACPORT.toString());
				qosRelevance.setObjId(id);
				qosRelevanceDao.delete(qosRelevance, connection);
			}

			// 删除对应的lag使用关系
			for (AcPortInfo acPortInfo : acportInfoList) {
				if (acPortInfo.getLagId() > 0) {// 如果ac为lag，把相应的lag变为被使用
					PortLagInfo portLagInfo = new PortLagInfo();
					portLagInfo.setId(acPortInfo.getLagId());
					portLagInfo.setType(1);
					portLagInfo = portLagService.selectLAGByCondition(portLagInfo).get(0);
					portLagInfo.setIsUsed(0);
					portLagService.updateStatus(portLagInfo);
				}
			}

			acDao.delete(acIdList, connection);
			if(!connection.getAutoCommit()){
				connection.commit();
			}
		} catch (Exception e) {
			connection.rollback();
			throw e;
		} finally {
			connection.setAutoCommit(true);
		}
	}
	
	/**
	 * 判断ac引用的该条QoS是否被其他ac使用
	 * @param qosRelavanceList 
	 */
	private void checkIsOccupy(int acId, List<QosRelevance> qosRelevanceList) {
		try {
			QosRelevanceDao qosRelevanceDao = new QosRelevanceDao();
			if(qosRelevanceList != null && !qosRelevanceList.isEmpty()){
				QosRelevance qosRelevance = new QosRelevance();
				for (QosRelevance relevance : qosRelevanceList) {
					qosRelevance.setSiteId(relevance.getSiteId());
					qosRelevance.setObjId(0);
					qosRelevance.setObjType(EServiceType.ACPORT.toString());
					qosRelevance.setQosGroupId(relevance.getQosGroupId());
					List<QosRelevance> qosList = qosRelevanceDao.queryByCondition(qosRelevance, connection); 
					if(qosList != null && qosList.size() > 1){
						relevance.setRepeat(true);
					}else{
						relevance.setRepeat(false);
					}
				}
			}
		} catch (Exception e) {
			ExceptionManage.dispose(e, this.getClass());
		}
	}
	
	private List<QosRelevance> getQosRelevanceList(int acId) throws Exception{
		QosRelevanceDao qosRelevanceDao = new QosRelevanceDao();
		QosRelevance qosRelevance = new QosRelevance();
		qosRelevance.setObjId(acId);
		qosRelevance.setObjType(EServiceType.ACPORT.toString());
		return qosRelevanceDao.queryByCondition(qosRelevance, connection);
	}


	/**
	 * 通过acIdList批量插叙
	 */
	public List<AcPortInfo> select(List<Integer> acIdList) throws Exception {
		List<AcPortInfo> acPortInfoList = null;
		List<Acbuffer> acbufferList = null;
		AcBufferService bufservice = null;
		try {
			acPortInfoList = acDao.queryByAcIdCondition(acIdList, connection);
			bufservice = (AcBufferService) ConstantUtil.serviceFactory.newService(Services.UniBuffer, this.connection);
			for (AcPortInfo acPortInfo : acPortInfoList) {
				acbufferList = bufservice.select(acPortInfo.getId());
				acPortInfo.setBufferList(acbufferList);
			}
			this.getAcQos(acPortInfoList);
		} catch (Exception e) {
			throw e;
		} finally {
//			UiUtil.closeService(bufservice);
		}
		return acPortInfoList;
	}

	public List<AcPortInfo> selectAll() throws Exception {
		List<AcPortInfo> acPortInfoList = null;

		try {
			acPortInfoList = acDao.queryAll(connection);
			this.getAcQos(acPortInfoList);
		} catch (Exception e) {
			throw e;
		}
		return acPortInfoList;
	}

	public List<AcPortInfo> selectBySiteId(Integer siteId) throws Exception {
		List<AcPortInfo> acPortInfoList = null;
		AcPortInfo acInfo = new AcPortInfo();
		acInfo.setSiteId(siteId);
		try {
			acPortInfoList = acDao.queryByCondition(acInfo, connection);
			this.getAcQos(acPortInfoList);
			this.getAcBuffer(acPortInfoList);
		} catch (Exception e) {
			throw e;
		}
		return acPortInfoList;
	}

	/**
	 * 把数据库里对应的流信息添加到ac中
	 * 
	 * @param acPortInfoList
	 * @throws Exception
	 */
	private void getAcBuffer(List<AcPortInfo> acPortInfoList) throws Exception {
		List<Acbuffer> acBufferList = null;
		AcBufferService bufservice = null;
		try {
			bufservice = (AcBufferService) ConstantUtil.serviceFactory.newService(Services.UniBuffer, this.connection);

			for (AcPortInfo acPortInfo : acPortInfoList) {

				acBufferList = bufservice.select(acPortInfo.getId());
				if (null != acBufferList && acBufferList.size() > 0) {
					acPortInfo.setBufferList(acBufferList);
				}
			}

		} catch (Exception e) {
			throw e;
		} finally {
//			UiUtil.closeService(bufservice);
		}

	}

	public List<AcPortInfo> queryByAcPortInfo(AcPortInfo acInfo) throws Exception {
		List<AcPortInfo> acPortInfoList = null;
		List<Acbuffer> acbufferList = null;
		AcBufferService bufservice = null;
		try {
			acPortInfoList = acDao.queryByCondition(acInfo, connection);
			bufservice = (AcBufferService) ConstantUtil.serviceFactory.newService(Services.UniBuffer, this.connection);
			for (AcPortInfo acPortInfo : acPortInfoList) {
				acbufferList = bufservice.select(acPortInfo.getId());
				acPortInfo.setBufferList(acbufferList);
			}
			this.getAcQos(acPortInfoList);
		} catch (Exception e) {
			throw e;
		} finally {
//			UiUtil.closeService(bufservice);
		}
		return acPortInfoList;
	}

	public int saveAcPortInfo(AcPortInfo acPortInfo) throws Exception {
		int result = 0;
		try {
			result = acDao.insert(acPortInfo, connection);
		} catch (Exception e) {
			throw e;
		}
		return result;

	}

	/**
	 * 查询ac
	 * 
	 * @param siteId
	 *            网元id
	 * @param xcid
	 *            设备名称
	 * @return
	 * @throws Exception
	 */
	public List<AcPortInfo> selectByCondition(AcPortInfo acPortInfo) throws Exception {

		List<AcPortInfo> acPortInfoList = null;
		try {
			acPortInfoList = acDao.queryByCondition(acPortInfo, connection);
			this.getAcQos(acPortInfoList);
		} catch (Exception e) {
			throw e;
		}
		return acPortInfoList;
	}

	/**
	 * 把QOS从数据据库查询出来添加到结果集中
	 * 
	 * @author kk
	 * 
	 * @param
	 * 
	 * @return
	 * @throws Exception
	 * 
	 * @Exception 异常对象
	 */
	private void getAcQos(List<AcPortInfo> acPortInfoList) throws Exception {
		QosInfoService qosInfoService = null;
		List<QosInfo> qosInfoList = null;
		try {
			qosInfoService = (QosInfoService) ConstantUtil.serviceFactory.newService(Services.QosInfo, this.connection);

			for (AcPortInfo acPortInfo : acPortInfoList) {
				qosInfoList = qosInfoService.getQosByObj(EServiceType.ACPORT.toString(), acPortInfo.getId());
				if (null != qosInfoList && qosInfoList.size() == 1) {
					acPortInfo.setSimpleQos(qosInfoList.get(0));
				}
			}

		} catch (Exception e) {
			throw e;
		} finally {
//			UiUtil.closeService(qosInfoService);
		}

	}

	/**
	 * 验证名字是否重复
	 * 
	 * @author kk
	 * 
	 * @param afterName
	 *            修改之后的名字
	 * @param beforeName
	 *            修改之前的名字
	 * 
	 * @return
	 * @throws Exception
	 * 
	 * @Exception 异常对象
	 */
	public boolean nameRepetitionBySingle(String afterName, String beforeName, int siteId) throws Exception {
		int result = this.acDao.query_nameBySingle(afterName, beforeName, connection, siteId);
		if (0 == result) {
			return false;
		} else {
			return true;
		}

	}

	/**
	 * 根据端口ID和vlanid 查询ac数据 武汉同步时用
	 * 
	 * @author kk
	 * @param acRelevanceArr 
	 * 
	 * @param
	 * 
	 * @return
	 * @throws Exception 
	 * @throws Exception
	 * 
	 * @Exception 异常对象
	 */
	public List<AcPortInfo> select_vlan(AcPortInfo acPortInfo, int[] acRelevanceArr) throws Exception  {
		List<AcPortInfo> acportInfoList = null;
		try {
			List<String> relevanceValueList = new ArrayList<String>();
			// 获取流中所有vlanid等关联规则的值
			for (Acbuffer buffer : acPortInfo.getBufferList()) {
				relevanceValueList.add(this.appendResult(acRelevanceArr, buffer));
			}
			acportInfoList = new ArrayList<AcPortInfo>();
			if (!relevanceValueList.isEmpty()) {
				List<AcPortInfo> acList = this.queryByAcPortInfo(acPortInfo);
				if(acList != null && !acList.isEmpty()){
					for (int i = 0; i < acList.size(); i++) {
						List<Acbuffer> bufferList = acList.get(i).getBufferList();
						for (int j = 0; j < bufferList.size(); j++) {
							Acbuffer buffer = bufferList.get(j);
							String result = this.appendResult(acRelevanceArr, buffer);
							if(relevanceValueList.contains(result)){
								acportInfoList.add(acList.get(i));
								break;
							}
						}
					}
				}
			}
		} catch (Exception e) {
			throw e;
		}
		return acportInfoList;
	}

	private String appendResult(int[] acRelevanceArr, Acbuffer buffer) {
		StringBuffer sb = new StringBuffer();
		sb.append("");
		if(acRelevanceArr[0] == 1)
			sb.append(buffer.getVlanId());
		if(acRelevanceArr[1] == 1)
			sb.append(buffer.getEightIp());
		if(acRelevanceArr[2] == 1)
			sb.append(buffer.getSourceMac());
		if(acRelevanceArr[3] == 1)
			sb.append(buffer.getTargetMac());
		if(acRelevanceArr[4] == 1)
			sb.append(buffer.getSourceIp());
		if(acRelevanceArr[5] == 1)
			sb.append(buffer.getTargetIp());
		return sb.toString();
	}

	public int updateUserType(AcPortInfo info) throws Exception {
		return acDao.update(info, connection);

	}

	/**
	 * 根据主键查询AC对象
	 * 
	 * @param id
	 *            主键
	 * @return
	 * @throws Exception
	 */
	public AcPortInfo selectById(int id) throws Exception {
		AcPortInfo acPortInfo = null;
		List<AcPortInfo> acPortInfoList = null;
		try {
			acPortInfo = new AcPortInfo();
			acPortInfo.setId(id);
			acPortInfoList = this.selectByCondition(acPortInfo);
			this.getAcQos(acPortInfoList);
			this.getAcBuffer(acPortInfoList);
			if (null != acPortInfoList && acPortInfoList.size() == 1) {
				acPortInfo = acPortInfoList.get(0);
			}
		} catch (Exception e) {
			throw e;
		}
		return acPortInfo;
	}

	public int updateActiveStatus(int siteId, int value) throws Exception {
		return this.acDao.updateActiveStatus(siteId, value,this.connection);
		
	}
	
	/**
	 * 同步时查询ac
	 * 
	 * @param siteId
	 *            网元id
	 * @param xcid
	 *            设备名称
	 * @return
	 * @throws Exception
	 */
	public List<AcPortInfo> selectByCondition_synchro(AcPortInfo acPortInfo) throws Exception {

		List<AcPortInfo> acPortInfoList = null;
		try {
			acPortInfoList = acDao.selectByCondition_synchro(acPortInfo, connection);
			this.getAcQos(acPortInfoList);
		} catch (Exception e) {
			throw e;
		}
		return acPortInfoList;
	}
	
	/**
	 * 跟新所有的ac的使用状态
	 * @param acIdList
	 * @throws Exception
	 */
	public void updateState(List<Integer> acIdList) throws Exception {

		try {
			if(acIdList != null && acIdList.size()>0){
				acDao.updateAcState(acIdList, connection);
			}
		} catch (Exception e) {
			e.printStackTrace();
//			throw e;
		}
	}
	
	/**
	 * 查询所有的关联端口的AC 主键ID
	 */
	/**
	 * 跟新所有的ac的使用状态
	 * @param acIdList
	 * @throws Exception
	 */
	public List<Integer> acByPort(int portId) throws Exception {
        List<Integer> ids = new ArrayList<Integer>();
		try {
			ids = acDao.selectByPortId(portId, connection);
		} catch (Exception e) {
			ExceptionManage.dispose(e, getClass());
		}
		return ids;
	}
	
	public int updateLanId(AcPortInfo info) throws Exception {
		return acDao.updateLanId(info, connection);

	}
}
